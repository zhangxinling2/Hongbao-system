### 业务概述与系统建模

#### 业务场景

礼包，庆祝，营销等

用例：发红包，收(抢)红包

#### 业务定义

##### 红包：一定数量和金额的红包序列

+ 红包是具有虚拟资金特征的商品
+ 发红包和收红包实际上是资金交易过程
+ 资金交易就是资金从一个账户流通到另一个账户的过程

那么发红包就是发红包的人向红包商购买红包，并支付金额，之后发布商品。收红包类似商品秒杀活动，区别就是不需要支付价格。

所以红包就可以定义成一个小而美的商品交易系统。

#### 红包业务模型

![image-20230822090825025](C:\Users\Administrator\OneDrive\图片\go笔记\红包业务.png)

#### 数据库物理模型设计

![image-20230822092906093](C:\Users\Administrator\OneDrive\图片\go笔记\资金账户数据库表.png)

这是对业务模型推导优化最后产出的物理模型，用户和账户是实体对象，账户流水是事务性数据。对账户模型来说，用户模型是在账户模型中的一个子集，体现在账户中的就是用户ID和用户名称。把用户模型和账户模型集成在一起，这样要查询用户信息时可以减少一次查询。最终产生两张表，账户表和账户流水表，两者都冗余用户ID和用户名称。

##### 从业务模型推到数据库物理模型

+ 可以一致可以不一致
+ 不能违背业务模型逻辑的前提下可以做一些优化
+ 冗余，合并，拆分，异构

![image-20230822105527253](C:\Users\Administrator\OneDrive\图片\go笔记\账户表和流水表.png)

##### 红包数据库物理模型的设计

![image-20230822112617950](C:\Users\Administrator\OneDrive\图片\go笔记\红包业务模型.png)

根据业务模型来看，商品，订单，库存，活动这四个模型都是一对一的关系，商品，库存，订单间是通过红包ID来关联，订单和活动之间是通过订单ID来关联。发红包时只使用，商品，订单，库存，活动这四个模型。订单和订单详情间是一对多的关系，通过订单ID关联，收红包只和订单明细，库存两个模型相关。

红包业务中的交易与通常商品不同，通常商品是标准的，商品属性是不变的，商品和订单之间是多对多关系，而红包属性每次都是不同的，红包商品和订单间是一对一的关系。

最后发现由于红包的特殊性，活动ID和订单ID是多余的，可以使用红包ID来表示。

![image-20230824143124268](C:\Users\Administrator\OneDrive\图片\go笔记\合并的红包物理模型.png)

在库存中主要维护红包剩余金额和红包剩余数量，在商品交易中，红包商品是一次性虚拟商品，库存也是在红包创建时产生，之后只会在收红包时扣减。所以把红包模型和库存模型合并。

订单中主要维护订单状态和支付状态，订单中所涉及的数量，金额等属性和红包中是一致的，所以在红包业务中，订单和红包是同时产生的，生命周期也是相同的。所以同样可以合并。

活动物理模型可有可无，与订单同理。可以有的理由是要存储链接，可以无的理由是，活动链接可以用来动态生成。

所以最后优化为两张表。

![image-20230829191941945](C:\Users\Administrator\OneDrive\图片\go笔记\最终红包模型.png)

![image-20230829192049317](C:\Users\Administrator\OneDrive\图片\go笔记\红包物理模型.png)

#### 红包算法

红包序列是按照红包金额和红包数量拆分后的子红包集合。

红包序列可以在发红包时生成，也可在收红包时生成。采用收红包时生成。

普通红包数量和单个金额固定，不需要算法。

碰运气红包：保证所有人都能拿到红包，每个人领到的序列总和是总金额，序列之间元素差异性要可以控制，大小分布可预期，防止产生不必要损耗

##### 二倍平均算法

思路：每次随机金额的平均值基本相等，剩余金额平均数的两倍做最大金额

```go
//二倍均值算法
func DoubleAverage(count, amount int64) int64 {
	if count <= 0 {
		return 0
	}
	if count == 1 {
		return amount
	}
	//计算出最大可用金额
	max := amount - min*count
	//计算最大可用平均值
	avg := max / count
	//二倍均值基础在加上最小金额，防止出现0值
	avg2 := 2*avg + min
	//随机红包金额序列元素，把二倍均值作为随机的最大数
	rand.Seed(time.Now().UnixNano())
	x := rand.Int63n(avg2) + min
	return x
}
```

##### 负库存负金额

是一个高并发的资金交易系统，存在资金交易安全和事务问题。

本质是要保证剩余数量和金额字段不能为负数。

直接使用update有较好的性能但容易出现负库存负金额，事务行锁稳定可靠，性能较差，容易死锁

由于剩余数量和属于金额不存在负数的场景，所以可以设计为无符号整型，这样在执行操作时如果出现负数，会出现越界错误，这样仍会出现很多无用的update。

乐观锁，在where条件中进行限制，降低开销。乐观锁在此种扣减场景中常常使用。

无符号+乐观锁   两个场景：资金账户转账业务逻辑中，支出时会涉及资金扣减；收红包时红包剩余数量和剩余金额的扣减场景

#### 架构演进

##### 单体系统

红包系统

view->红包服务->钱包账户，两个模块可以沟通数据库

##### 微服务

随着服务量增加，红包单体应用演进为微服务架构，拆分了红包服务和资金账户服务，共享数据库

##### 分库

随着业务量增加，数据库读写性能遭到制约，运行时两个服务在数据库操作时互相影响。

随着微服务架构演进，微服务数量不断增加，部署的实例不断增加就需要服务发现和配置管理。

![image-20230830142607692](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统微服务架构.png)

##### 红包系统应用架构

![image-20230830142826477](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统应用架构.png)

### 架构设计

+ 用户接口层：用于人机交互，用来向外显示信息，解析用户指令并将信息传给应用层，通常是网络交互，进程间沟通。比如基于HTTP的Tomcat等
+ 应用层：用来协调领域模型和其他领域组件工作，定义软件要完成的所有任务，对外提供各种功能，对内交于领域层完成各种逻辑。发红包就属于应用层的功能，发红包时检查余额等业务逻辑属于领域层。就是常说的service
+ 领域层：业务核心层，几乎所有业务逻辑在这里实现。
+ 基础设施层：为上面各层提供基础的技术。与数据库等交互放在此。

#### 物理分层

![image-20230830145752505](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统物理分层.png)

这里把应用层和领域层做了一些调整，应用层接口实现和领域层放到了核心层，数据库访问层也放到了核心层。总体和四层架构保持一致。

+ 应用服务接口层：协调各个领域层实现功能，不包括任何业务逻辑，一些数据验证，权限安全，日志等都放在这层，用来向外暴露业务能力。定义访问方式，异常等。
+ 应用服务实现层：具体业务能力的实现。实现职责和逻辑有接口层决定，是私有的。
+ 领域层：与四层架构相同。
+ 数据库访问层：包含最小粒度的原子操作，只负责持久化数据。

#### 代码架构设计

![image-20230830150815247](C:\Users\Administrator\OneDrive\图片\go笔记\代码架构设计.png)

红包模块架构与资金账户架构相同，命名规则也是类似的。

##### 代码包设计

![image-20230830162144545](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统包结构设计.png)

###### apis:存放用户接口层

- 文件名称可以描述其业务含义的单词
- 定义外部交互逻辑和交互形式：UI，restful接口
- 不涉及任何业务，随时可替换为其他形式的交互方式
- services构造和初始化

###### services包：存放应用层接口

- 文件名称可以描述其业务含义的单词
- 需要对外暴露的
  - DTO，service interface
  - 枚举，常数等

###### core包：应用层实现，领域层和数据访问层所有代码

- 业务含义+分层名称

### 基础设计和编码

#### 使用枚举

使用iota，有状态或需要持久化就不能使用iota。在启动后，只存在与内存，不参与进程间交互。

#### 使用json

marshal和unmarshal。推荐库：jsoniter

使用var json = jsoniter.ConfigCompatibleWithStandardLibrary替换为此库

#### 基础设施层

##### 配置设计

###### 配置文件

可读性，可编辑性要强

推荐等级：ini， properties(缺少分组的特性), yaml ,toml, xml， json(最好不要)

静态配置选择yaml或xml

动态配置采用ini或properties

程序级别的配置文件可以不分组，如boot.ini,config.ini

应用程序级别：app-mysql.properties

环境不同：多个环境使用同一套配置，使配置变量化。

在微服务，分布式下：使用分布式配置中心。

###### 配置设计

此项目中将由单个程序演化为微服务，所以使用props配置工具库。支持prop,ini,consul,etcd,nacos等key/value形式的配置。可以使用花括号来使用变量。

使用prop配置客户端工具库加持+ini格式。

go get -u github.com/tietang/props    安装props

使用方式

```go
func main() {
	file := kvs.GetCurrentFilePath("config.ini", 1)//跳过层级是因为，NewIniFileConfigSource是在运行项目根目录去找文件，而定义的文件低了一层所以要跳过一层。
	conf := ini.NewIniFileConfigSource(file)
	port := conf.GetIntDefault("app.service.port", 18080)
	fmt.Println(port)
}
```

编写配置的PropsStarter

starter属于基础设施所以放在infra包中。infra新添一个base目录，把props.go建立在此目录中，建立PropsStarter，并给一个初始化方法初始化配置文件，暴露一个Props来返回kvs.ConfigSource使外部能够拿到配置文件。

##### 应用程序启动管理器

管理所有的Starter，同样属于基础设施层，直接在infra下面建立一个boot.go来管理所有starter。

建立BootApplication结构体，用来管理程序加载启动的一个生命周期，它需要一个StarterContext，围绕此来初始化，不同的生命周期间来交互。还需要一个配置configsource，要贯穿所有的starter。

结构体定义完后，定义整个的生命周期：

Start方法：初始化所有的生命周期，1.初始化starter 2.安装starter 3.启动starter

###### starter注册器

在Starter.go中定义的starter注册器starterRegistry里面放入Starter的切片。

有一个AllStarters方法用来返回切片用来暴露注册器。

并且在Starter中已经初始化好注册器。

###### 初始化，安装，启动starter

根据切片中的顺序一个一个的初始化starter，遍历注册器中的starter，使用starter的init来一个一个初始化，安装和启动同理，不过在Starter接口中定义了一个StartBlocking()用来描述这个starter是否可阻塞。为了防止阻塞要做一个处理，判断一下是否是可阻塞的。如果是可阻塞的并且是最后一个starter，那么直接执行不然的话使用go来新开协程执行。

###### 启动管理器的初始化

使用New传入ConfigSource，返回BootApplication，因为这是所有的初始化，所以直接放入空的context

###### 注册starter

由于starter需要贯穿各个包，所以在整个包下定义一个app.go在里面的init进行starter的注册，这样可以手动指定注册顺序，可以很好的管理注册顺序。如何starter不影响其他的starter，那么可以在自己的init中单独注册。

现在PropsStarter是最高级的，所以把它放进去，在main函数的文件中导入包即可。

main报错，找不到config.ini,因为把加载配置文件移植到了main函数中，从外部传入，所以props中不需要加载了，但仍然需要初始化，在生命周期中去管理。StarterContext定义一个Props方法返回ConfigSource，配置文件就从上下文获取。那么就可以在NewBootApplication中set。这样props中就可以直接使用上下文获取了、

##### mysql starter编码

###### 数据库连接池

+ 数据库连接是有限且昂贵的资源
+ 连接过程：socket连接->认证->协议协商...->命令和结果->关闭

数据库连接池解决了连接复用，减少了内存分配和消耗，提高资源利用。

原理：

+ 资源池中维护一定数量的数据库连接
+ 数据库存取时获取连接，结束时返回连接池

###### dbx数据库扩展工具

```
go get -u github.com/tietang/dbx
```

简单高效,最大限度保留原生特性

高性能，支持orm的基础上，最大限度减少性能损坏，秒杀系统很适合

自动表名和字段名称映射

支持自定义表名和字段名称映射

dbx使用dbx.Settings结构体来配置参数

使用此来进行数据库starter，在base下创建dbx.go。

同props，在里面定义一个database变量，暴露DbxDataBase方法来使外部获得database。

定义DbxDatabaseStarter struct,同样包含infra.BaseStarter,实现Setup方法，把数据库放在安装阶段，在里面从上下文中获取到props配置文件，使用settings配置。kvs.Unmarshal(conf,&settings,"mysql")就可以把配置文件中的parent为mysql的解析到settings中。最后使用dbx.open打开数据库，并给全局变量database赋个值。

最后就可以在init中注册了。

找不到mysql，因为在dbx.go中没有导入mysql。

##### log starter编码

log.go的init中要定义日志格式，日志级别，控制台高亮显示，日志文件和滚动配置。

###### 定义日志格式

```go
formatter:=&log.TextFormatter{}
formatter.FullTimestamp=true//开启时间戳
formatter.TimestampFormat="2006-01-02.15:04:05.000000"//24小时制为15,12小时为03
```

`log.SetFormatter(fomatter)`接收一个接口以决定日志格式

###### 日志级别

`log.SetLevel`,上线后不能使用debug，因为太多会影响性能，所以设置一个开关

```go
level:=os.Getenv("log.debug")
```

对level做一个判断，如果为true就setLevel为debug

###### 高亮显示

通过formatter.ForceColors=true,formatter.DiasbleColors=false使日志高亮。

###### prefixed

内置的log功能有限，所以使用第三方库prefixed，是兼容内部log的。

```
go get github.com/x-cray/logrus-prefixed-formatter
```

把&log改为&prefixed即可，提供了强制格式化功能。ForceFormatting=true，还可以自定义高亮颜色。

```go
formatter.SetColorScheme(&prefixed.ColorScheme{InfoLevelStyle:"green",    WarnLevelStyle:"yellow",                               /...})
```

###### 日志文件

使用rotatelogs来输出日志文件和滚动配置

```go
//设置日志文件
content, err := rotatelogs.New("/doc/log/system.log"+"-%Y%m%d",
		rotatelogs.WithLinkName("/doc/log/system.log"),
		rotatelogs.WithMaxAge(6*time.Minute),
		rotatelogs.WithRotationTime(time.Minute),
		rotatelogs.WithRotationCount(5)) //number 默认7份 大于7份 或到了清理时间 开始清理
log.SetOutput(content)
```

##### 验证器

数据校验，保证数据的正确性和完整性，会遍布在应用的各个层面。

避免数据校验和业务逻辑耦合太紧。

###### validator

go get gopkg.in/go-playground/validator.v9

支持结构体字段验证，还允许嵌套结构体跨 field 和struct，支持自定义字段类型和错误，支持深入map，slice，array。

###### 例子

```go
type User struct {
   FirstName string `validate:"required"` //非空字段
   LastName  string `validate:"required"`
   Age       uint8  `validate:"gte=0,lte=130"`  //大于等于0，小于等于130
   Email     string `validate:"required,email"` //非空且email字段
}
user := &User{
		FirstName: "firstName",
		LastName:  "lastName",
		Age:       136,
		Email:     "fl163.com",
	}
	validate := validator.New()
	//翻译器
	//zh包，"github.com/go-playground/locales/zh"
	zh_cn := zh.New()
	//万能翻译器，保存所有的语言环境和翻译数据"github.com/go-playground/universal-translator"
	uni := ut.New(zh_cn, zh_cn)
	//翻译器
	Trans, found := uni.GetTranslator("zh")
	if found {
        //向验证添加翻译器
		err := vtzh.RegisterDefaultTranslations(validate, Trans)
		if err != nil {
			fmt.Println(err)
		}
	}
	err := validate.Struct(user)
	if err != nil {
		_, ok := err.(*validator.InvalidValidationError)
		if ok {
			fmt.Println(err)
		}
		errs, ok := err.(validator.ValidationErrors)
		if ok {
			for _, err := range errs {
//翻译错误
                fmt.Println(err.Translate(Trans))
			}
		}
	}
```

###### 验证器starter

同样的定义一个validate为Validate指针，Validate方法来返回这个变量。翻译器同理定义一个translator

同样需要一个ValidatorStarter结构体

验证器与其它基础组件间的依赖性不强，只需要在网络地址监听之前，即真正接收请求之前，实际业务代码执行之前创建好即可，所以放入Init中构造，注册顺序放在web之前即可。

把之前的例子改为logrus.Error()来打印

##### web框架starter

###### Iris

go get -u github.com/kataras/iris

可以使用party管理分组party，路由分组中也支持单独使用中间件user。也可错误信息自定义OnErrorCode OnAnyErrorCode两者会覆盖。

```go
func main() {
   app := iris.Default()

   app.Get("/hello", func(context iris.Context) {
      context.WriteString("hello world")
   })
   v1 := app.Party("/v1")
   v1.Use(func(ctx iris.Context) {
      logrus.Info("自定义中间件")
      ctx.Next()
   })
   v1.Get("/user/{id:uint64 min(2)}", func(context iris.Context) {
      id := context.Params().GetUint64Default("id", 0)
      context.WriteString(strconv.Itoa(int(id)))
   })
   v1.Get("/orders/{action:string prefix(a_)}", func(ctx iris.Context) {
      a := ctx.Params().Get("action")
      ctx.WriteString(a)
   })
   app.OnAnyErrorCode(func(context iris.Context) {
      context.WriteString("出现错误")
   })
   err := app.Run(iris.Addr(":8082"))
   fmt.Println(err)
```

###### Iris阶段

初始化阶段：

+ 创建iris application实例
+ iris日志组件的配置和扩展
+ 主要中间件的配置：recover中间件和自定义日志中间件

启动阶段：

+ 把系统注册的路由信息打印到控制台，方便查看
+ 从配置中读取配置的端口，启动iris web服务监听端口

定义为可阻塞的starter

###### Iris starter

与之前一样，定义一个irisApplication，Iris()对外暴露此变量。

IrisServerStarter结构体，两个阶段，Init和Starter

Init：

创建Iris实例，recover中间件和自定义日志中间件：定义一个InitIris返回一个Application单独管理，New出app后使用use利用recover，日志中间件使用logger.Config{}创建，特别的其中的logFunc要集成app中的logger方法app.Logger.Infof(),定义好后使用app.User(logger.New(cfg))即可

日志组件的配置和扩展：使用application的logger使用其install安装logrus的标准logger

Starter：

系统注册的路由信息打印到控制台：使用getRoutes获得路由切片

启动Iris：通过Run监听地址。端口从配置app.server.port中拿到

可阻塞，实现一个starter的StarterBlocking返回一个true

### 资金账户核心业务开发(单体版)

#### 开发顺序

![image-20230915140919156](C:\Users\Administrator\OneDrive\图片\go笔记\红包业务开发流程.png)

在这先设计资金账户模块，因为红包模块的资金交易依赖于资金账户模块。

#### 账户模块

##### 账户创建流程

![image-20230915141117674](C:\Users\Administrator\OneDrive\图片\go笔记\账户创建流程.png)

##### 账户转账流程

![image-20230915141249614](C:\Users\Administrator\OneDrive\图片\go笔记\账户转账流程.png)

#### 账户模块数据库表

##### Account表

![image-20230915141349658](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统Account表.png)

##### Account Log表

资金账户流水表

![image-20230915142056940](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统Accountlog.png)

![image-20230915142545837](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统AccountLog2.png)

trade与log的区别是trade是外部传入的。log是内部创建的。账户流水表还要几个辅助字段，

change_type:资金交易类型  0.创建账户，>0收入，<0支出

change_flag：快速标识交易变化，0创建账户，-1出账，1进账

status：交易状态，0无效数据，-1转账失败，1成功

decs:交易描述

create_at:交易创建时间

#### 资金账户模块服务接口设计和定义

##### AccountService

接口的粒度和需求是一致的。

四个接口：

账户创建，储值，转账，账户信息查询

###### 账户创建接口定义

![image-20230915161645082](C:\Users\Administrator\OneDrive\图片\go笔记\账户创建接口.png)

Amount由于使用浮点数会丢失精度所以使用string来传递

CreateAccount的入参就是AccountCreatedDTO出参就是*AccountDTO和一个ERROR

###### 转账和存储

![image-20230915161919096](C:\Users\Administrator\OneDrive\图片\go笔记\转账和处置.png)

TransferStatus定义为int8别名

转账失败定义为-1，余额不足定义为0，成功为1

TransfeStatusFailure|SufficientFunds|Success

ChangeType同样为int8别名

AccountCreated为0，进账StoreValue为1,

红包资金涉及红包资金支出，收入，过期

支出EnvelopeOutgoing为-2，Incoming为2，Expire为3

资金交易的变化标识

ChangeFlag为int8别名，记录资金交易变化的状态

创建账户FlagAccountCreated 0

支出记为FlagTransferOut -1

进账记为FlagTransferIn 1

###### 账户查询接口

![image-20230915162024042](C:\Users\Administrator\OneDrive\图片\go笔记\账户查询接口.png)

#### 资金账户模块数据库访问层定义和编码

##### DBX

DBX持久化对象映射

+ 至少每一个表都要定义一个持久化对象
+ 把驼峰命名转化为下划线
+ 表名默认结构体名

映射也可使用db作为tag来标识如`db:"username"`

+ uni 标识唯一索引
+ id 标识主键
+ omitempty 字段更新和写入时会被忽略
+ -更新，写入，查询时都被忽略

##### 编码

在core下的的accounts文件夹定义dao_account和dao_account_log数据库访问,po_account和po_account_log定义持久化对象。持久化对象的结构体字段和数据库的字段一一对应。

![image-20230918145742256](C:\Users\Administrator\OneDrive\图片\go笔记\account持久化对象.png)

###### 账户表数据库访问代码

把代码定义为AccountDao，dbx使用runner来执行事务，所以AccountDao包含一个runner *dbx.TxRunner

###### Account数据库访问

每一个方法代表一个原子操作

**查询单实例**

GetOne(accountNo string)*Account

dbx的runner有个GetOne方法传入的是带唯一标识的结构体指针，AccountNo就是个唯一标识，返回数据是否存在和error

```go
func (dao *AccountDao) GetOne(accountNo string) *Account {
   a := &Account{AccountNo: accountNo}
   ok, err := dao.runner.GetOne(a)
   if err != nil {
      logrus.Error(err)
      return nil
   }
   if !ok {
      return nil
   }
   return a
}
```

**通过用户ID和账户类型查询账户信息**

GetByUserId(userId string,accountType int)*Account

使用runner.Get来查询，三个参数，1.传出的指针，2.SQL语句，3.参数

```go
func (dao *AccountDao) GetOne(accountNo string) *Account {
   a := &Account{AccountNo: accountNo}
   ok, err := dao.runner.GetOne(a)
   if err != nil {
      logrus.Error(err)
      return nil
   }
   if !ok {
      return nil
   }
   return a
}
```

**账户数据插入**

```go
func (dao *AccountDao) Insert(a *Account) (id int64, err error) {
   rs, err := dao.runner.Insert(a)
   if err != nil {
      return 0, err
   }
   return rs.LastInsertId()
}
```

**账户余额更新**

```go
func (dao *AccountDao) Insert(a *Account) (id int64, err error) {
   rs, err := dao.runner.Insert(a)
   if err != nil {
      return 0, err
   }
   return rs.LastInsertId()
}
```

**账户状态更新**

###### Account数据库测试

使用Convey框架来测试，"github.com/smartystreets/goconvey/convey"

在base包中定义Tx方法来便于执行事务

```go
func TxContext(ctx context.Context, fn func(runner *dbx.TxRunner) error) error {
   return DbxDataBase().Tx(fn)
}
func Tx(fn func(runner *dbx.TxRunner) error) error {
   return TxContext(context.Background(), fn)
}
```

**GetOne测试**

在事务的方法中实例化Dao，之后使用Convey来测试Insert后GetOne

在base包中定义Tx方法来便于执行事务

```go
func TestAccountDao_GetOne(t *testing.T) {
	err := base.Tx(func(runner *dbx.TxRunner) error {
		dao := &AccountDao{runner: runner}
		Convey("通过编号查询账户数据", t, func() {
			a := &Account{
				AccountNo:   ksuid.New().Next().String(),
				AccountName: "测试资金账户",
				UserId:      ksuid.New().Next().String(),
				UserName:    sql.NullString{String: "测试用户", Valid: true},
				Balance:     decimal.NewFromFloat(100),
				Status:      0,
				CreatedAt:   time.Time{},
				UpdatedAt:   time.Time{},
			}
			id, err := dao.Insert(a)
			So(err, ShouldBeNil)
			So(id, ShouldBeGreaterThan, 0)
			na := dao.GetOne(a.AccountNo)
			So(na, ShouldNotBeNil)
			So(na.Balance.String(), ShouldEqual, a.Balance.String())
			So(na.CreatedAt, ShouldNotBeNil)
			So(na.UpdatedAt, ShouldNotBeNil)
		})
		return nil
	})
	if err != nil {
		logrus.Error(err)
	}
}
```

###### 测试bug

爆空指针错误，因为db没有初始化，新建一个textx文件夹，建立一个init文件用来初始化，把main中获取配置文件和registry都放进这里，然后在test中引用一下。

之后报错时间0000-00-00格式错误，因为实体对象定义时没有定义上omitempty,写入时没被忽略，需要具体值。

有报错 unsupported Scan, storing driver.Value type []uint8 into type *time.Time，因为打开数据库时没有parseTIme，在配置中加上options.parseTime = true

###### AccountLog数据库访问

需要三个方法

**通过流水编号查询流水记录**

GetOne(logNo string)*AccountLog

**通过交易编号查询流水记录**

GetByTradeNo(tradeNo string)*AccountLog

通过runner的get

**写入流水记录**

Insert(l *AccountLog)(id int64,err error)

###### AccountLog数据库测试

与Account类似

#### 业务领域层

domain_account和domain_account_log

是有状态的，每次使用时都要实例化

创建领域模型结构体，里面有两个持久化对象account和accountLog

##### 资金账户创建

根据之前创建流程需要：

创建流水的记录，流水的tradeNo是从外部传入的，logNo是在创建流水记录时创建的，accountNo系统生成。

所以需要创建logNo和accountNo的逻辑。

###### 创建逻辑

createAccountLogNo(){}

暂时采用ksuid的ID生成策略来创建，后期会优化成可读性较好的，分布式ID

createAccountNo(){}

与创建LogNo相同

createAccountLog(){}

它是基于账户创建的account创建,创建账户逻辑在前。

流水的交易主体信息，交易对象信息，交易金额，交易变化属性。在创建时，交易主体，交易对象是一样的

```go
func (domain *accountDomain) createAccountNo() {
   domain.account.AccountNo = ksuid.New().Next().String()
}
func (domain *accountDomain) createAccountLogNo() {
   domain.accountLog.LogNo = ksuid.New().Next().String()
}
func (domain *accountDomain) createAccountLog() {
   domain.accountLog = AccountLog{}
   domain.createAccountLogNo()
   domain.accountLog.TradeNo = domain.accountLog.LogNo

   domain.accountLog.UserId = domain.account.UserId
   domain.accountLog.AccountNo = domain.account.AccountNo
   domain.accountLog.Username = domain.account.UserName.String

   domain.accountLog.TargetUserId = domain.account.UserId
   domain.accountLog.TargetAccountNo = domain.account.AccountNo
   domain.accountLog.TargetUsername = domain.account.UserName.String

   domain.accountLog.Balance = domain.account.Balance
   domain.accountLog.Amount = domain.account.Balance

   domain.accountLog.ChangeFlag = services.FlagAccountCreated
   domain.accountLog.ChangeType = services.AccountCreated
}
```

###### 账户创建

基本创建写好之后就可以写账户创建的逻辑代码

Create(dto services.AccountDTO)(*services.AccountDTO,error){}

先将账户对象创建好，之后需要将AccountDTO转换成持久化对象，那么就在Account下定义一个FromDTO方法来赋值，这样就需要修改AccountDTO，使其的属性与Account相对应。

然后就使用createAccountNo，设置一下UserName的Valid为true

接着创建账户流水持久化对象，使用刚才的createAccountLog

接着就可以创建数据库对象，数据库对象也是有状态的，每次运行使用的连接和事务都是不同的。

还是使用Tx来运行，插入账户数据和流水数据，插入后就有了时间，在从数据库中使用GetOne更新领域的account，之后使用定义的ToDTO方法把Account对象转换成DTO对象，需要先定义一个*AccountDTO来存储。

```go
func (domain *accountDomain) Create(dto services.AccountDTO) (*services.AccountDTO, error) {
   domain.account = Account{}
   domain.account.FromDTO(&dto)
   domain.createAccountNo()
   domain.account.UserName.Valid = true

   domain.accountLog = AccountLog{}
   domain.createAccountLog()

   accountDao := AccountDao{}
   accountLogDAO := AccountLogDAO{}
   var rdto *services.AccountDTO
   base.Tx(func(runner *dbx.TxRunner) error {
      accountDao.runner = runner
      accountLogDAO.runner = runner
      rs, err := accountDao.Insert(&domain.account)
      if err != nil {
         return err
      }
      if rs <= 0 {
         return errors.New("创建账户失败")
      }
      rs, err = accountLogDAO.Insert(&domain.accountLog)
      if err != nil {
         return err
      }
      if rs <= 0 {
         return errors.New("创建账户流水失败")
      }
      domain.account = *accountDao.GetOne(domain.account.AccountNo)
      return nil
   })
   rdto = domain.account.ToDTO()
   return rdto, nil
}
```

##### 测试

领域层账户创建代码是通过DTO来传输，先创建一个AccountDTO，把必要信息写入。之后new一个领域模型测试Create。

##### 资金账户转账

在AccountDomain基础上来编写，Transfer(dto service.AccountTransferDTO)(status services.TransferStatus,err error)

###### 逻辑

如果交易变化是支出，修正amount，要修正amount，需要transferDTO的属性加一个amount来获得。

创建账户流水记录：创建账户流水持久化对象，在AccountLog下定义FromTransferDTO方法来转化DTO，之后把logNo创建好。

检查余额是否足够：通过乐观锁来验证，

更新余额的同时来验证是否余额够，更新成功后写入流水记录：还是通过事务来写入流水记录，使用之前写的UpdateBalance来更新，如果changeFlag是扣减，校验余额。

先查询出来交易主体的account，然后给流水的Balance赋值，之后就可以插入这条流水记录。

##### 测试

首先要有两个账户dto，交易主体账户要有余额

3个用例：余额充足，金额转入其他账户；余额不足，转出金额；充值。

账户创建和domain创建与之前测试相同

在用例中定义两个TradeParticipator，之后就可以定义AccountTransferDTO进行domain的transfer。由于获取余额的方法还没有写，这里就先不判断余额，等后续补全。

##### 账户查询

两个查询：

根据账户编号来查询账户信息

根据用户ID来查询红包账户

###### 账户编号查询

GetAccount(accountNo string)*services.AccountDTO

通过事务进行GetOne得到账户，最后返回account.ToDTO()

###### 用户ID来查询

GetEnvelopeAccountByUserId(userId string)*services.AccountDTO

跟上面查询基本一样

不过这里使用dao的GetByUserId，其中类型在const中定义，一个红包账户，一个系统账户

##### 测试

这个测试加到之前的资金账户转账中即可。测试报错，在第二个测试用例中GetAccount得到了nil,第三个测试用例中出现红包账户不存在。

在观察后发现，在总convey中Create账户后，在子convey中每次读AccountNo时，都会变化，只有第一个Convery才能正常读到。因为convey执行顺序为每次子convey执行前都会执行总convey。

后来发现Create账户时事务执行的err没返回，加上返回。

出现'Error 1062 (23000): Duplicate entry '2VhGX9XaZMXvRNTkAjvb7bnMDnq-1' for key 'account.idx_userid_type''，这表示已经有这个值，但是每次执行总的convey都会新建ksuid，但这里出现了第一次创建的ksuid，所以出现了冲突，由于userID是在convey之外创建，数据库中有唯一性索引的约束，所以出现了冲突。所以只能先注释掉之前的来测试后续。

##### 账户流水查询

根据流水ID来查询账户流水

根据交易编号来查询账户流水

###### 根据流水ID

GetAccountLog(logNo string)*services.AccountLog

使用logDao的GetOne来查询，最后使用log.ToDTO()来返回,所以需要在accounts文件中新定义一个AccountLogDTO。

###### 根据交易编号

代码跟根据流水ID是一样的

GetAccountLogByTradeNo(tradeNo string)*services.AccountLog

#### 应用服务层

代码放在accounts包下的services.go中，实现定义的AccountService接口，这里的实现禁止对外暴露。

所以定义accountService struct

service是领域层代码的组合，或者说调度，所以方法中都要先实例化领域层

##### CreateAccount

验证输入参数合法，执行账户创建的业务逻辑。

验证之前已经注册好validate，可以直接使用base下的validate().Struct(&dto)来验证结构体是否有错误。要断言一下错误类型为*validator.InvalidValidationError。

再断言为*validator.ValidationErrors,如果断言为此，迭代errs，用日志输出，logrus.Error(e.Translate(base.Translator()))

接着创建accountDTO,继续调用domain的create方法创建accountDTO.

##### Transfer

验证代码与上方一样，把错误的返回值修改为statusFailure。

接着写转账逻辑，同样的对amount做一下转化，因为transferDTO中有一个amount，amountStr，把转化的值再赋给DTO。

继续检查dto的ChangeFlag，如果是转出，判断dto.ChangeType,如果大于0，返回转账失败的错误，因为必须小于0.如果是收入那么判断相反。

##### StoreValue

储值是转账的一种特殊形式，交易主体和交易目标都是同一个人，交易类型为储值，flag为入账。修改完这三个属性就可以调用transfer来完成。

##### 两个查询

同样建一个domain，之后直接调用相应的函数即可。

##### 测试

创建账户直接把之前的测试挪过来改造。

转账，也是准备两个，从账户1转入账户2一定金额，账户1余额足够；从账户1转入账户2一定金额，余额不足；给账户1储值

转完之后验证余额数目。

#### web接口定义

放在apis下的web包下，代码放在Account中。

定义web api时对每一个子业务定义统一的前缀，资金账户的根路径定义为/account，版本号/v1/account

##### party

iris可以通过party函数定义分组的路由，所以在init中定义一个groupRouter iris.party，并初始化它。

##### 接口

只是和HTTP协议的一个适配。

为了统一返回，在base包下定义Res结构体

```go
type ResCode int
const(
	ResCodeOk = 1000
    ResCodeValidationError = 2000
    ResCodeRequestParamsError = 2100
    ResCodeInnerServerError=5000
    ResCodeBizError = 6000
)
type Res struct{
    Code ResCode	`json:"code"`
    Message string	`json:"message"`
    Date interface{}	`json:"data"`
}
```

`

###### 账户创建方法

/v1/account/create Post方法

1.获取请求参数

它的数据是从requestBody中获取，格式是json，iris中可以使用readJSON来读取并转成AccountCreateDTO，转换之后检查一下，检查代码写在base包中。定义res，如果出错了就改变res的code，message为err.Error(),之后使用iris的Json写回res。

2.执行创建账户代码

交互使用的是service，由于accountService没有对外暴露的接口，所以在接口定义的文件中定义一个IAccountService变量，之后此定义一个方法用来对外暴露账户应用服务，之后在accountService结构体文件中实例化这个变量，在init函数中实例化，避免多次实例化所以定义var once sync.Once,在init中使用once.Do来实例化。

检查函数：

```go
//结构体指针检查验证，如果传入的interface为nil，就通过log.Panic函数抛出一个异常
//被用在starter中检查公共资源是否被实例化了
func Check(a interface{}) {
	if a == nil {
		_, f, l, _ := runtime.Caller(1)
		strs := strings.Split(f, "/")
		size := len(strs)
		if size > 4 {
			size = 4
		}
		f = filepath.Join(strs[len(strs)-size:]...)
		log.Panicf("object can't be nil, cause by: %s(%d)", f, l)
	}
}
```

```go
unc init() {
   groupRouter := base.Iris().Party("/v1/account")
   create(groupRouter)
}
func create(groupRouter iris.Party) {
   groupRouter.Post("/create", func(context iris.Context) {
      account := service.AccountCreatedDTO{}
      err := context.ReadJSON(&account)
      r := base.Res{
         Code:    base.ResCodeOk,
         Message: "",
         Date:    nil,
      }
      if err != nil {
         r.Code = base.ResCodeRequestParamsError
         r.Message = err.Error()
         context.JSON(r)
         return
      }
      ser := service.GetAccountService()
      dto, err := ser.CreateAccount(account)
      if err != nil {
         r.Code = base.ResCodeRequestParamsError
         r.Message = err.Error()
      }
      r.Date = dto
      context.JSON(&r)
   })
}
```

###### 测试

使用postMan发送接送出现404Not Found，说明没有引用web包导致没有运行包的init，所以在app.go中空引用一下这个包，报空指针错误，因为web包的init在Iris的init之前执行了导致iris还没有实例化。所以有依赖的初始化不能使用init函数，所以改造代码。改造完代码后发现程序直接执行完毕，发现是因为boot.go中判断StartBlocking()，iris是startBlocking的，所以它新开了一个routine来处理iris的start，之后调用Iris()得不到这里的Iris。所以暂时先不判断startblocking，全部顺序start。

###### 测试后完善代码

为了更方便执行web api注册逻辑，写一个注册组件，在infra下面新建一个Initializer文件，定义一个接口，包含一个Init()函数。

定义一个注册器InitializeRegister，包含一个切片，定义一个Register方法，方法中直接通过append。

在infra包下建立一个web.go来进行web包的注册，定义一个apiInitializerRegister变量，定义RegisterApi注册方法和GetApiInitializers获取api方法，还需要一个WebApiStarter，实现Setup,使用foreach循环GetApiInitializers执行Init，最后注册在iris之后。

在api中需要一个AccountApi结构体来实现Init函数，在init中把AccountApi注册进去。

又出现IAccountService为空，说明service的init没有运行，所以在app.go中空引用一下。

###### 转账方法

/v1/account/transfer	Post

先重构一下账户创建方法，是为了符合单一职责原则 ，那么Init()方法就让它做API注册的事情，下面的接口就做handler。

基本与创建账户一样，使用的AccountTransferDTO，使用的方法是Transfer，最后添加一个对status的判断

查询红包账户接口：/v1/account/envelope/get

查询账户信息接口：/v1/account/get

接口注册在init中注册。

接口参数传入party

### 红包核心业务开发实践(并发版)

#### 流程

##### 发红包

![image-20231007142042819](C:\Users\Administrator\OneDrive\图片\go笔记\发红包.png)

##### 收红包-事务锁流程

![image-20231007142235614](C:\Users\Administrator\OneDrive\图片\go笔记\事务锁流程.png)

锁库存是通过事务行锁来完成

##### 收红包-乐观锁

![image-20231007142503282](C:\Users\Administrator\OneDrive\图片\go笔记\收红包乐观锁.png)

#### 数据库表设计

##### 红包商品表

![image-20231007142837520](C:\Users\Administrator\OneDrive\图片\go笔记\红包商品表1.png)

![image-20231007143011810](C:\Users\Administrator\OneDrive\图片\go笔记\红包商品表2.png)

##### 红包详情表

![image-20231007143257846](C:\Users\Administrator\OneDrive\图片\go笔记\红包详情表1.png)

![image-20231007143504240](C:\Users\Administrator\OneDrive\图片\go笔记\红包详情表2.png)

#### 服务接口定义和设计

##### 主要接口

![image-20231007143610993](C:\Users\Administrator\OneDrive\图片\go笔记\红包接口.png)

##### 发红包

![image-20231007143801590](C:\Users\Administrator\OneDrive\图片\go笔记\发红包接口.png)

##### 收红包

![image-20231007143943514](C:\Users\Administrator\OneDrive\图片\go笔记\收红包接口.png)

##### 红包信息查询

![image-20231007144029677](C:\Users\Administrator\OneDrive\图片\go笔记\红包信息查询.png)

##### 红包退款

![image-20231007144134834](C:\Users\Administrator\OneDrive\图片\go笔记\红包过期退款.png)

##### 实现

基本与账户接口相同，接口定义同样放在services包下，创建一个envelop.go文件来存放，枚举定义放在envelop_consts中。

枚举值：

DefaultBlessing默认祝福语

订单类型：OrderType int 有两个值Sending值为1和Refund值为2

支付状态：PayStatus int 有四个值PayNothing为1，Paying为2，Payed为3，PayFailure为4.

红包订单状态：OrderStatus，四个值 Create为1，Sending为2，Expired为3，Disabled为4.

红包类型：General和Lucky为1和2



定义完红包接口后，在定义它的暴露函数GetRedEnvelopService，与账户实现相同。

#### 数据库访问层编码

同样是放在core下envelops包下，放在dao_goods.go下的是访问红包商品表的代码，dao_item.go是访问红包详情表。两个持久化对象是放在po_goods和po_item。

##### 红包商品表的Dao

同样建立一个RedEnvelopeGoodsDao struct包含runner

###### 插入

Insert(po *RedEnvelopeGoods)(int64,error)

使用runner的Insert插入就可以了

###### 查询，根据红包编号

GetOne(envelopNo string)*RedEnvelopeGoods

通过runner的GetOne方法

###### 更新红包余额和数量

不使用事务行锁而是使用乐观锁

使用锁来避免负金额问题，在数据库定义时，他们定义为无符号整型，在数据库层面上避免负金额。在DAO层面上使用乐观锁，通过在WHERE子句中判断红包剩余金额和数量来解决两个问题。

1.负库存	2.减少实际的数据更新

UpdateBalance(envelopeNo string,amount decimal.Decimal)(int64,error)

由于每次扣减的红包数量都为1，所以就不需要传参，可以在SQL语句中直接写死，通过runner的Exec来执行

sql语句:update red_envelop_goods set remain_amount=remain_amount-CAST(? AS DECIMAL(30,6)), remain_quantity = remain_quantity-1 where envelope_no=?

//最重要的,乐观锁的关键

and remain_quantity>0 and remain_amount >=CAST(? AS DECIMAL(30,6))

###### 更新订单状态

整体逻辑是和余额扣减是一样的

UpdateOrderStatus(envelopeNo string,status services.OrderStatus)(int64,error)

###### 过期，把过期所有红包都查询出来，分页，limit，offset，size

传入查询位置和数量

FindExpired(offset,size int)[]RedEnvelopeGoods{}

使用runner的Find函数



##### 红包订单详情表的Dao

查询GetOne 插入Insert

#### 发红包业务领域层编码

同样的，代码放在domain_goods和domain_item中

##### domain_goods

goodsDomain结构体包含RedEnvelopeGoods

###### 创建和保存红包

**生成一个红包编号**

createEnvelopeNo

**创建红包商品对象**

Create(goods services.RedEnvelopGoodsDTO),在此方法中使用Goods的FromDTO将DTO转换成Goods，把几个sqlNullString的valid设置一下。再重置一下红包的总金额和单个金额，判断一下红包类型，如果是普通红包把它的Amount设置为单个金额乘份数，如果是碰运气红包，那么就把单个金额设置为0。给剩余数量和剩余金额赋值，再设置过期时间，通常是当前时间加上24小时。初始化订单状态为create，然后再创建红包编号。

**保存到红包商品表**

Save()(id int64,err error)

调用base.Tx来进行保存，首先构建好DAO对象，然后调用Insert

**创建并保存红包商品**

CreateAndSave(goods services.RedEnvelopeGoodsDTO)(id int64,err error)

调用两个方法创建红包商品后保存。

###### 发送红包

由于逻辑较多，所以单独建立一个domain_sending文件

SendOut(goods services.RedEnvelopeGoodsDTO)(activity *services.RedEnvelopeActivity,err error)

创建红包商品，创建活动，保存红包商品，红包金额支付，在支付过程中 1.需要红包中间商的红包资金账户，它定义在配置文件中，实现初始化到资金账户表中 2.从红包发送人的资金账户中扣减红包金额 3.将扣减的红包总金额转入中间商红包资金账户。 扣减金额没问题，返回活动

在配置文件中加一个system.account的节点，需要四个参数

userID=10001 userName=系统红包账户 accountName=系统红包账户 accountNo=1000002019010101000000000001

保证AccountNo为32位，定义好后就要把它从配置文件中读取出来进行处理。

把过程加到base中的props文件处理时，那么就需要一个结构体来承载这个方法把它叫SystemAccount，里面定义四个成员就是在配置文件中定义的。同样的定义一个变量，和一个暴露变量的方法GetSystemAccount。使用Once来初始化这个变量。通过props库下的kvs包的unmarshal函数来读取配置。如果失败就panic。

1.创建红包商品，使用写好的Create

2.创建活动，直接new一个，之后把他的两个成员赋值即可，它的RedEnvelopeGoodsDTO需要从最后的Goods使用自定义的ToDTO来转化过去；链接使用fmt.sprintf("http://%s/v1/envelope/%s/link",)第一个参数是域名，域名是从配置文件中获取，所以配置文件中再加一个节点envelope，其下有link=/v1/envelope/link domain=http://localhost, 同样在Props中加上获取link的函数使用GetDefault来获取值和一个获取域名的函数获得域名。那么在这里就使用这两个方法获得域名和link，之后就不需要使用sprintf了，使用path.Join即可，最后一个参数是红包id。

3.保存红包商品，还是使用Tx，保存红包商品和红包金额支付都在Tx中，保存就是使用之前写好的Save。这里转账直接使用资金账户的转账接口。

有一个关键问题：事务逻辑问题，保存红包商品和红包金额的支付必须保证全部成功或全部失败。所以把这两个操作放在同一个数据库事务中。为了使用资金账户的接口，要在资金账户的Domain中暴露一个实例NewAccountDomain。

而在Transfer中还有一个base.Tx,需要改造一下，需要一个新的方法

```go
func WithValueContext(parent context.Context, runner *dbx.TxRunner) context.Context {
	return context.WithValue(parent, TX, runner)
}

func ExecuteContext(ctx context.Context,fn func(*dbx.TxRunner) error){
    tx,ok:=ctx.Value(TX).(*dbx.TxRunner)
    if !ok||tx==nil{
        log.Panic("是否在事务函数块中使用?")
    }
    return fn(tx)
}
```

ExecuteContext和WithValueContext相互作用，在context中传递TxRunner这个对象，就可以在不同的方法中使用同一个事务。

把原来的Transfer函数改为TransferWithContextTx，参数添加一个context，然后把使用的Tx改为使用ExecuteTx，之后为了保证Transfer本身的事务性，新的Transfer方法中使用Tx来运行，在里面定义一个ctx对象，使用WithValueContext(context.Background(),runner)来建立,之后调用TransferWithContextTx。之前保存红包同样需要改造，Save和CreateAndSave，参数都加上ctx。

红包金额支付需要两个主体，所以定义两个TradeParticipator，主体是红包主体，目标是系统红包账户，转账的编号直接使用红包的编号，金额就是红包总金额，变化类型是支出，flag是transferOut，描述是红包金额支付。之后使用TransferWithContextTx即可。

入账

它的交易主体和对象是相反的。

最后把活动的DTO使用Goods的ToDTO赋值

#### 发红包应用服务层

代码同样是放在service下

初始化的代码逻辑是和资金账户中的逻辑相同。

定义redEnvelopeService结构体

##### SendOut

SendOut的逻辑就是

1.验证

验证逻辑是和资金账户的验证逻辑相同，所以对验证代码进行提炼，提炼为一个公共的函数ValidateStruct(s interface())(err error)，放在validator中

2.,获取红包发送人的资金账户信息

通过accountService的通过ID获得账户来获取账户信息。

通过自定义的ToGoods将SendingDTO转化为GoodsDTO,然后把AccountNo赋值过去即可，这里判断一下，给祝福语赋一下默认值，在判断一下红包类型如果是普通红包，那么传过来的amount就是单个红包的金额，重新给Amount和AmountOne赋值，给AmountOne赋值amount，给Amount重新初始化

要注意SendingDTO中的Amount是单个子红包的Amount

3.执行发送红包逻辑

先创建红包商品的domain，因为domain对象是有状态的所以每次使用都要new，然后使用它的SendOut即可

##### 测试

先获取service，之后通过CreatedDTO来创建测试账户，分别验证发送普通红包和碰运气红包

#### 发红包web用户接口层

同样是放在api下，逻辑是和账户的api逻辑是一样的。

#### go内置RPC替代web用户接口层

##### RPC接口层注册

首先要创建RPC的service，把它放在base文件夹下 rpc.go,编写GoRPCStarter struct 集成BaseStarter，这个starter需要实现的是Start方法。

在方法中使用rpc.NewServer来创建rpc server，配置文件新建节点app下rpc.port为8082.

之后就监听网络接口 net.Listen,如果错误就panic，没有错误就输出一个信息

之后就处理网络连接和请求，使用协程来Accept。

还需要把接口注册进server中，所以需要暴露这个server，定义一个RPCServer来返回rpc的server

server暴露出后还需要一个注册函数，用来注册RPC接口，RpcRegister(ri interface{}),方便调试，这里面输出一个信息，反射得到ri的类型后输出。

它的注册阶段放在Iris之前

##### RPC接口注册

在apis下新建gorpc文件夹，代码放在envelope.go中

定义EnvelopeRpc结构体，定义SendOut(in serviecs.RedEnvelopeSendingDTO,out *services.RedEnvelopeActivity)error方法，其内容直接使用应用服务层的SendOut即可。把结果使用自定义的CopyTo(out)传到out中。

在init中把EnvelopeRpc注册到rpc服务中，运行发现爆空指针错误，代表在注册时服务还没有初始化，所以要改进一下代码。

所以在init()中注册是不可取的，无法保证它一定运行在starter之后，所以在编写一个GoRpcApiStarter放在gorpc包之下，实现Init，把注册代码放到这里面，在GoRPCStarter中把NewServer放到Init中，初始化之后直接赋值给rpcServer。最后把APIStarter放在RPCStarter之后。

go内置的RPC接口有一些规范

1.入参和出参都要作为方法参数

2.方法必须有两个参数，并且是可导出类型

3.第二个参数(返回值)必须是指针

4.方法返回值要返回error类型

5.方法必须是可导出的

##### rpc使用实例

使用rpc.Dial来与接口通信，使用Call来调用远程方法EnvelopeRpc.SendOut,后面传入参数

#### 抢红包订单详情业务领域层

订单详情爱red_envelope_item表中，同样代码放在domain_item中，itemDomain，里面保存item，domain要做

1.生成itemNo

createItemNo

2.创建item

Create(item services.RedEnvelopeItemDTO)

是通过FromDTO来将DTO转化成Item，把NullString的valid设置一下

3.保持item数据

Save(ctx context.Context)(id int64,err error)

和之前发红包是一样的，使用ExecuteContext来执行事务,首先创建item的dao，之后去执行insert

4.通过itemNo查询抢红包数据

GetOne(ctx context.Context,itemNo string)(dto *service.RedEnvelopeItemDTO)

同样的使用ExecuteContext,创建dao后使用其GetOne,得到后使用ToDTO进行转化

5.通过envelopeNo查询已抢到的红包列表

FindItems(envelopeNo string)(itemDTOs []*service.RedEnvelopeItemDTO)

通过Tx来执行,在dao中新建一个FindItems方法，通过sql来查询，然后使用FInd来执行sql，那么在事务中就使用这个FindItems。之后将持久化对象转化为dto

##### Receive方法

在goodsDomain下

Receive(ctx context.Context,dto services.RedEnvelopeReceiveDTO)(item *services.RedEnvelopeItemDTO,err error)

1.创建收红包的订单明细 preCreatItem

2.查询出当前红包的剩余数量和剩余金额信息

3.效验剩余红包和剩余金额：

- 如果没有剩余，直接返回无可用红包金额

4.使用红包算法计算红包金额

5.使用乐观锁更新语句，尝试更新剩余数量和剩余金额：

- 如果更新失败，也就是返回0，表示无可用红包数量和金额，抢红包失败

- 如果更新成功，也就是返回1，表示抢到红包

6.保存订单明细数据

7.将抢到的红包金额从系统红包中间账户转入当前用户的资金账户 transfer

1.preCreateItem(dto services.RedEnvelopeReceiveDTO)

由于在这里面会使用到ItemDomain，所以把它嵌入到goodsDomain中，在此方法中把dto的属性赋值给Item

2.需要在domainGoods中新增查询红包商品信息的方法 Get(envelopeNo string)(goods *RedEnvelopeGoods),通过base.Tx，执行dao下的GetOne

3.查询后进行校验，判断剩余金额和剩余数量，剩余数量使用Cmp来比较。

4.计算红包金额，在domainGoods下定义nextAmount(goods *RedEnvelopeGoods)(amount decimal.Decimal,err error),如果剩余数量为1，那么就直接返回剩余金额，如果是普通红包，那么返回amountOne，如果是碰运气红包，将剩余金额乘以100转化成分，使用IntPart取出整数值，之后使用二倍均值算法，算出来后在除以100

5.使用base.Tx执行5,6,7三个步骤，首先定义goods的dao，使用UpdateBalance，通过其返回值来判断是否出错，出错就返回先前的错误。成功了就保存订单明细，补充一下数量，支付状态，账户编号，剩余金额，金额，然后调用WithValueContext得到txCtx,然后使用Save

6.transfer(ctx context.Context,dto services.RedEnvelopeReceiveDTO)(status TransferStatus,err error)

主体是系统红包账户，目标是dto中的对象

#### 收红包应用服务层

1.参数校验，方法跟之前的相同

2.获取当前红包用户账户信息，通过AccountService里的根据用户ID查询来获取

3.进行尝试收红包，方法在goodsDomain中

##### 测试

1.准备几个红包资金账户，用于发红包和收红包

使用accountService，定义AccountDto的切片，size定义为10，直接把之前的测试中建立dto代码移过来，然后选第一个用来发红包

2.使用其中一个用户发送一个红包

3.使用发送红包数量的人收红包
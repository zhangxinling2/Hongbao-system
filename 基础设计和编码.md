### 业务概述与系统建模

#### 业务场景

礼包，庆祝，营销等

用例：发红包，收(抢)红包

#### 业务定义

##### 红包：一定数量和金额的红包序列

+ 红包是具有虚拟资金特征的商品
+ 发红包和收红包实际上是资金交易过程
+ 资金交易就是资金从一个账户流通到另一个账户的过程

那么发红包就是发红包的人向红包商购买红包，并支付金额，之后发布商品。收红包类似商品秒杀活动，区别就是不需要支付价格。

所以红包就可以定义成一个小而美的商品交易系统。

#### 红包业务模型

![image-20230822090825025](C:\Users\Administrator\OneDrive\图片\go笔记\红包业务.png)

#### 数据库物理模型设计

![image-20230822092906093](C:\Users\Administrator\OneDrive\图片\go笔记\资金账户数据库表.png)

这是对业务模型推导优化最后产出的物理模型，用户和账户是实体对象，账户流水是事务性数据。对账户模型来说，用户模型是在账户模型中的一个子集，体现在账户中的就是用户ID和用户名称。把用户模型和账户模型集成在一起，这样要查询用户信息时可以减少一次查询。最终产生两张表，账户表和账户流水表，两者都冗余用户ID和用户名称。

##### 从业务模型推到数据库物理模型

+ 可以一致可以不一致
+ 不能违背业务模型逻辑的前提下可以做一些优化
+ 冗余，合并，拆分，异构

![image-20230822105527253](C:\Users\Administrator\OneDrive\图片\go笔记\账户表和流水表.png)

##### 红包数据库物理模型的设计

![image-20230822112617950](C:\Users\Administrator\OneDrive\图片\go笔记\红包业务模型.png)

根据业务模型来看，商品，订单，库存，活动这四个模型都是一对一的关系，商品，库存，订单间是通过红包ID来关联，订单和活动之间是通过订单ID来关联。发红包时只使用，商品，订单，库存，活动这四个模型。订单和订单详情间是一对多的关系，通过订单ID关联，收红包只和订单明细，库存两个模型相关。

红包业务中的交易与通常商品不同，通常商品是标准的，商品属性是不变的，商品和订单之间是多对多关系，而红包属性每次都是不同的，红包商品和订单间是一对一的关系。

最后发现由于红包的特殊性，活动ID和订单ID是多余的，可以使用红包ID来表示。

![image-20230824143124268](C:\Users\Administrator\OneDrive\图片\go笔记\合并的红包物理模型.png)

在库存中主要维护红包剩余金额和红包剩余数量，在商品交易中，红包商品是一次性虚拟商品，库存也是在红包创建时产生，之后只会在收红包时扣减。所以把红包模型和库存模型合并。

订单中主要维护订单状态和支付状态，订单中所涉及的数量，金额等属性和红包中是一致的，所以在红包业务中，订单和红包是同时产生的，生命周期也是相同的。所以同样可以合并。

活动物理模型可有可无，与订单同理。可以有的理由是要存储链接，可以无的理由是，活动链接可以用来动态生成。

所以最后优化为两张表。

![image-20230829191941945](C:\Users\Administrator\OneDrive\图片\go笔记\最终红包模型.png)

![image-20230829192049317](C:\Users\Administrator\OneDrive\图片\go笔记\红包物理模型.png)

#### 红包算法

红包序列是按照红包金额和红包数量拆分后的子红包集合。

红包序列可以在发红包时生成，也可在收红包时生成。采用收红包时生成。

普通红包数量和单个金额固定，不需要算法。

碰运气红包：保证所有人都能拿到红包，每个人领到的序列总和是总金额，序列之间元素差异性要可以控制，大小分布可预期，防止产生不必要损耗

##### 二倍平均算法

思路：每次随机金额的平均值基本相等，剩余金额平均数的两倍做最大金额

```go
//二倍均值算法
func DoubleAverage(count, amount int64) int64 {
	if count <= 0 {
		return 0
	}
	if count == 1 {
		return amount
	}
	//计算出最大可用金额
	max := amount - min*count
	//计算最大可用平均值
	avg := max / count
	//二倍均值基础在加上最小金额，防止出现0值
	avg2 := 2*avg + min
	//随机红包金额序列元素，把二倍均值作为随机的最大数
	rand.Seed(time.Now().UnixNano())
	x := rand.Int63n(avg2) + min
	return x
}
```

##### 负库存负金额

是一个高并发的资金交易系统，存在资金交易安全和事务问题。

本质是要保证剩余数量和金额字段不能为负数。

直接使用update有较好的性能但容易出现负库存负金额，事务行锁稳定可靠，性能较差，容易死锁

由于剩余数量和属于金额不存在负数的场景，所以可以设计为无符号整型，这样在执行操作时如果出现负数，会出现越界错误，这样仍会出现很多无用的update。

乐观锁，在where条件中进行限制，降低开销。乐观锁在此种扣减场景中常常使用。

无符号+乐观锁   两个场景：资金账户转账业务逻辑中，支出时会涉及资金扣减；收红包时红包剩余数量和剩余金额的扣减场景

#### 架构演进

##### 单体系统

红包系统

view->红包服务->钱包账户，两个模块可以沟通数据库

##### 微服务

随着服务量增加，红包单体应用演进为微服务架构，拆分了红包服务和资金账户服务，共享数据库

##### 分库

随着业务量增加，数据库读写性能遭到制约，运行时两个服务在数据库操作时互相影响。

随着微服务架构演进，微服务数量不断增加，部署的实例不断增加就需要服务发现和配置管理。

![image-20230830142607692](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统微服务架构.png)

##### 红包系统应用架构

![image-20230830142826477](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统应用架构.png)

### 架构设计

+ 用户接口层：用于人机交互，用来向外显示信息，解析用户指令并将信息传给应用层，通常是网络交互，进程间沟通。比如基于HTTP的Tomcat等
+ 应用层：用来协调领域模型和其他领域组件工作，定义软件要完成的所有任务，对外提供各种功能，对内交于领域层完成各种逻辑。发红包就属于应用层的功能，发红包时检查余额等业务逻辑属于领域层。就是常说的service
+ 领域层：业务核心层，几乎所有业务逻辑在这里实现。
+ 基础设施层：为上面各层提供基础的技术。与数据库等交互放在此。

#### 物理分层

![image-20230830145752505](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统物理分层.png)

这里把应用层和领域层做了一些调整，应用层接口实现和领域层放到了核心层，数据库访问层也放到了核心层。总体和四层架构保持一致。

+ 应用服务接口层：协调各个领域层实现功能，不包括任何业务逻辑，一些数据验证，权限安全，日志等都放在这层，用来向外暴露业务能力。定义访问方式，异常等。
+ 应用服务实现层：具体业务能力的实现。实现职责和逻辑有接口层决定，是私有的。
+ 领域层：与四层架构相同。
+ 数据库访问层：包含最小粒度的原子操作，只负责持久化数据。

#### 代码架构设计

![image-20230830150815247](C:\Users\Administrator\OneDrive\图片\go笔记\代码架构设计.png)

红包模块架构与资金账户架构相同，命名规则也是类似的。

##### 代码包设计

![image-20230830162144545](C:\Users\Administrator\OneDrive\图片\go笔记\红包系统包结构设计.png)

###### apis:存放用户接口层

- 文件名称可以描述其业务含义的单词
- 定义外部交互逻辑和交互形式：UI，restful接口
- 不涉及任何业务，随时可替换为其他形式的交互方式
- services构造和初始化

###### services包：存放应用层接口

- 文件名称可以描述其业务含义的单词
- 需要对外暴露的
  - DTO，service interface
  - 枚举，常数等

###### core包：应用层实现，领域层和数据访问层所有代码

- 业务含义+分层名称

### 基础设计和编码

#### 使用枚举

使用iota，有状态或需要持久化就不能使用iota。在启动后，只存在与内存，不参与进程间交互。

#### 使用json

marshal和unmarshal。推荐库：jsoniter

使用var json = jsoniter.ConfigCompatibleWithStandardLibrary替换为此库

#### 基础设施层

##### 配置设计

###### 配置文件

可读性，可编辑性要强

推荐等级：ini， properties(缺少分组的特性), yaml ,toml, xml， json(最好不要)

静态配置选择yaml或xml

动态配置采用ini或properties

程序级别的配置文件可以不分组，如boot.ini,config.ini

应用程序级别：app-mysql.properties

环境不同：多个环境使用同一套配置，使配置变量化。

在微服务，分布式下：使用分布式配置中心。

###### 配置设计

此项目中将由单个程序演化为微服务，所以使用props配置工具库。支持prop,ini,consul,etcd,nacos等key/value形式的配置。可以使用花括号来使用变量。

使用prop配置客户端工具库加持+ini格式。

go get -u github.com/tietang/props    安装props

使用方式

```go
func main() {
	file := kvs.GetCurrentFilePath("config.ini", 1)//跳过层级是因为，NewIniFileConfigSource是在运行项目根目录去找文件，而定义的文件低了一层所以要跳过一层。
	conf := ini.NewIniFileConfigSource(file)
	port := conf.GetIntDefault("app.service.port", 18080)
	fmt.Println(port)
}
```

编写配置的PropsStarter

starter属于基础设施所以放在infra包中。infra新添一个base目录，把props.go建立在此目录中，建立PropsStarter，并给一个初始化方法初始化配置文件，暴露一个Props来返回kvs.ConfigSource使外部能够拿到配置文件。

##### 应用程序启动管理器

管理所有的Starter，同样属于基础设施层，直接在infra下面建立一个boot.go来管理所有starter。

建立BootApplication结构体，用来管理程序加载启动的一个生命周期，它需要一个StarterContext，围绕此来初始化，不同的生命周期间来交互。还需要一个配置configsource，要贯穿所有的starter。

结构体定义完后，定义整个的生命周期：

Start方法：初始化所有的生命周期，1.初始化starter 2.安装starter 3.启动starter

###### starter注册器

在Starter.go中定义的starter注册器starterRegistry里面放入Starter的切片。

有一个AllStarters方法用来返回切片用来暴露注册器。

并且在Starter中已经初始化好注册器。

###### 初始化，安装，启动starter

根据切片中的顺序一个一个的初始化starter，遍历注册器中的starter，使用starter的init来一个一个初始化，安装和启动同理，不过在Starter接口中定义了一个StartBlocking()用来描述这个starter是否可阻塞。为了防止阻塞要做一个处理，判断一下是否是可阻塞的。如果是可阻塞的并且是最后一个starter，那么直接执行不然的话使用go来新开协程执行。

###### 启动管理器的初始化

使用New传入ConfigSource，返回BootApplication，因为这是所有的初始化，所以直接放入空的context

###### 注册starter

由于starter需要贯穿各个包，所以在整个包下定义一个app.go在里面的init进行starter的注册，这样可以手动指定注册顺序，可以很好的管理注册顺序。如何starter不影响其他的starter，那么可以在自己的init中单独注册。

现在PropsStarter是最高级的，所以把它放进去，在main函数的文件中导入包即可。

main报错，找不到config.ini,因为把加载配置文件移植到了main函数中，从外部传入，所以props中不需要加载了，但仍然需要初始化，在生命周期中去管理。StarterContext定义一个Props方法返回ConfigSource，配置文件就从上下文获取。那么就可以在NewBootApplication中set。这样props中就可以直接使用上下文获取了、

